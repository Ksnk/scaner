# Служебные утилиты

Основное назначение проекта - обеспечить комфортную среду для отладки и обслуживания приложений на сайте. Для этого вместе с ядром системы ставится целевой сценарий, в котором уже и описываются все необходимые действия.

Сценарный файл представляет собой один или несколько файлов со специальной разметкой, по которой автоматически строятся элементы формы для ввода параметров и вызова функций класса.

Ниже идет описание некоторых классов ядра системы.

## Autoload

Статический класс для поддержки PSR-0. Основное преимущество перед конкурентами - компактность, универсальность. Поддерживается запуск в phar и сканирование классов как в файловой системе (приоритет), так и внутри phar. При наличии - автоматически подключает autoload из composer'а. 

    \Autoload::map(['\\Ksnk\\scaner' => '']);
    
При поиске файлов все классы с таким префиксом будут искаться как классы без этого префикса.     

    \Autoload::register(['~/libs/template', '~/template']);
    
Добавляет каталоги для поиска файлов    


### Методы

- register(...) - параметры - массив каталогов, в которых будет инициироваться поиск. Заодно инициируется автолоад загрузчик.

        \Autoload::register(['~/libs/template', '~/template']);
    
- map - параметр - ассоциативный массив `класс`=>`имя файла без расширения`

        \Autoload::map(['\\Ksnk\\scaner' => '']);
        
- find - поиск по имени файла. В файловой системе, потом в phar, если он есть. Символ `~` в начале заменяется на индекс-каталог системы. (значение константы INDEX_DIR или каталог файла autoload.php )       
 
### Примеры

`Autoload::register(array('~/core', '~/libs', '~'));` - добавить каталоги, константа ~ заменяется на каталог, определенный в константе INDEX_DIR. Если константы нет - используется каталог, в котором размещается autoload.php.

`Autoload::map(array('xSphinxDB'=>'xDatabaseLapsi'));` - для инициализации класса xSphinxDB будет включен файл xDatabaseLapsi.php. 

## Scaner

Сканер предназначен для несложного парсинга текстов.
В качестве предмета анализа может быть строка, или имя файла.

Методы сканера

- found - логическое свойство. Устанавливается после каждого поиска. Было найдено что-то в результате поиска или не было.
- finish - длина анализируемого текста. Для текста в виде handle - не установлена.

- position(int) - установка курсора на указанную позицию в тексте.

- newbuf(string) - новый текст в виде строки

- newhandle(string|handle) - новый текст в виде имени файла или открытого handle.

- getResult - получить результат последнего сканирования.

- scan (reg/pattern,[N,Name,...])
Метод применяет регулярку или строку для поиска к тексту, начиная с текущего положения курсора. В случае успешного поиска - положение курсора сдвигается на последний символ найденой строки. Если используется регулярка - в результат поиска будут вписаны значения из захваченных масок регулярки с нужными именами. Если используется строка - в результате будет вся строка, содержащая подстроку.

- syntax - рудиментарный синтаксический разбор. Пример разбора атрибутов тега. 

         $scaner->scan('~<link~si')->until('~>~si')->syntax([
            'tag' => '\w+',
            'value' => '(?:"[^"]*"|\'[^\']*\'|[^\'">]*)'
         ], '~:tag:=:value:(?<fin>)~sm',
            function ($line) use (&$link) {
              if($line['tag']=='rel') $link['rel']=trim($line['value'],'"\'');
              if($line['tag']=='href') $link['href']=trim($line['value'],'"\'');
              return true;
            });
          $scaner->until();

## JobList

JobList - это класс, обеспечивающий хранение списка заданий и последовательное его исполнение.

Интерфейс JL достаточно прост. В него можно поместить задание по имени-классу-файлу для инклюда, с указанием параметров,
можно запустить на выполнение следующее задание, можно сохранить JL и восстановить его из сохранения.
Сохранение и восстановление списка заданий идет обычным json-сериалайзом.
Каждое задание атомарно и не может быть прервано. Это значит, что все задания должны выполняться быстро.
В частности, это значит, что если заданию таки надо выполняться долго,
то ему, заданию, должна быть предоставлена возможность добавиться еще раз в тот же JobList.

### Методы JL

- **store/load**, параметр - имя рессурса для хранения
- **appendJob**(array(class,method), paramlist) - добавить в список новое задание. Каждый параметр обязан быть сериализуемым
- **append_scenario** (callable, paramlist) - добавить новый метод из существующего сценария.
- **donext**(timeInSeconds) - продолжить выполнение задач, до исчерпания указаного количства секунд.

## Task

В качестве заданий в JobList вставляются специальные функции.

# Web морда

Web клиент представляет собой страничку со списком всех возможных Task'ов и с возможностью вручную
установить параметры этих Task'ов. Все возможные Task'и - это объекты с родителем scenario и специальной разметкой в заголовках функций.
Для автоматизации сего процесса, используется специальный диалект
DocType. Для каждого параметра Task есть возможность уточнить его тип и содержимое.

Отмеченное задание может быть добавлено в список задач.

## Разметка файлов scenario

В описании сценарного класса необходим тег **tags**

     /**
      * Class xparcer_scenario
      * @tags ~debug
      */

Теги можно перечислять через запятую, формы, определенные в классе, появятся во всех разделах с этими тегами. 
Перед названием тега возможно указание `~` - при этом этот тег не будет выводится в меню сценария, но добраться до сценария можно явно указав его в командной строке

Каждая функция сценария, имеющая префикс `do_` должна иметь полное описание в стиле phpDocs 

    /**
     * Тестировать
     * @param string $a :radio[1:one|3:two|4:four|5:five] 1-й параметр
     * @param $b
     * @param int|string $c :select[one|3:two|4:four|five] 3-й параметр
     * @param array $d :checkbox[1:да|2:заодно и удалить] Полностью?
     */
    function do_test0($a,$b,$c=4,$d=array()){
      ...

Перед блоком описания параметров обязано быть описание функции, которое будет выводится в описании формы. Каждый параметр, может быть доопределен описателем типа, онначинается с символа `:`, после чего идет имя типа и, возможно, в квадратных скобках - дополнительные параметры. После формального описателя может следовать подпись к элементу, если подписи нет - вместо него используется имя параметра. При описании дополнительных значений - `1:one` значение, которое принимает параметр `1`, а подпись, выводящаяся в форме `one`, если значения нет - значение будет совпадать с подписью.
 
 - **radio** `:radio[1:one|3:two|4:four|5:five] 1-й параметр` - будет сформирован html элемент radio, с элементами. перечисленными в квадратных скобках. Значением параметра будут одно из 1,2,3,4,5 в зависимости от выбора пользователя, подписью к каждому элементу radio будут `one two...`.
 
 - **select** `:select[one|3:two|4:four|five] 3-й параметр` - будет сформирован html элемент select, с элементами. перечисленными в квадратных скобках. Значением параметра будет одно из `one`,3,4,`five` в зависимости от выбора пользователя, подписью к каждому элементу radio будут `one two...`.
 
 - **checkbox** `:checkbox[1:да|2:заодно и удалить] Полностью?` - будет сформирован элемент checkbox, с элементами. перечисленными в квадратных скобках. Значением параметра будет массив с выбранными значениями.
 
 - **file** `:file[*.xml|*.yml] выберите файл` будет сформирован элемент select,
  со списком всех `xml` и `yml` из каталога `/tmp` в корне проекта, и  с возможностью загрузки файлов.  Файл будет подгружен в каталог `/tmp`
  проекта, если его  нет - можно его создать и обеспечить возможность перезаписи. Поле поддерживает Drag&drop из
  эксплорера Windows. В функцию прилетает полное имя файла в системе
                                                            
 - **textarea** - будет сформирован элемент textarea для ввода длиной строки с переводами строк.
  
 - **files** - `:files выберите файлы` поле для загрузки некольких файлов. По функционалу схож с file, но параметры в функцию передаются массивом 
          
# история переделок

- если после первого поста в очереди обнаруживаем задачи - задача прерывается до достижения таймаута и клиенту предлагается быстро послать iframe запрос на довыполнение оставшегося списка задач. (Не доделано... Пока в осмысленности этого действия сомневаюсь)